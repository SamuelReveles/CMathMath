import java_cup.runtime.*;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

parser code
{:
  public CMathMathParser(java_cup.runtime.Scanner s, ConsoleController consoleController) {
    super(s);
    this.consoleController = consoleController;
  }

  @Override
  public void report_error(String message, Object info) {
    Symbol sym = (Symbol) info;
    int line = sym.left + 1;
    int col = sym.right + 1;
    consoleController.println(String.format("Error de sintaxis en la línea %d, columna %d (token: %s)", line, col, sym.value));
  }

  @Override
  public void report_fatal_error(String message, Object info) {
    consoleController.println("Error de sintaxis irrecuperable");
    throw new RuntimeException("Análisis sintáctico abortado por error irrecuperable");
  }

  private Map<String, Complex> variables = new HashMap<>();
  private ConsoleController consoleController;
:}

terminal double REAL, IMAGINARY, DEGREES;
terminal PLUS, MINUS, MULTIPLICATION, DIVISION, POW, ROUND;
terminal String PRINT, LEFT_PARENTH, RIGHT_PARENTH, DADO, SI, EQUIVALE,
  SINO, PEROSI, MIENTRAS, DESDE, CON, AVANZAR, TALQUE, CONJUNTO, PI,
  LEFT_BRACE, RIGHT_BRACE, ID, SIN, COS, TAN, SEC, CSC, COT, COMMA, EQUALS,
  UNION, INTERSECT, STRING;

non terminal codigo;
non terminal List<Instruction> instrucciones;
non terminal Instruction instruccion;
non terminal List<Instruction> bloque;
non terminal SetExpression expresionConjunto;
non terminal List<String> parametros;
non terminal List<ComplexExpression> listaExpresionesComplejos;
non terminal ComplexExpression expresionComplejo;

precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, POW, ROUND;
precedence left UNION, INTERSECT;

start with codigo;

codigo ::=
    instrucciones:ins
    {:
      for (Instruction in : ins)
      {
        in.run();
      }
    :}
;

instrucciones ::= 
    instruccion:in instrucciones:moreIns
    {:
      List<Instruction> instructions = new ArrayList<>();
      instructions.add(in);
      instructions.addAll(moreIns);
      RESULT = instructions;
    :}
  | instruccion:in
    {:
      List<Instruction> instructions = new ArrayList<>();
      instructions.add(in);
      RESULT = instructions;
    :}
  | error instrucciones
;

bloque ::= 
    LEFT_BRACE instrucciones:ins RIGHT_BRACE
    {:
      RESULT = ins;
    :}
;

instruccion ::= 
    PRINT expresionComplejo:e
    {:
      RESULT = new PrintInstruction(e, consoleController);
    :}
  | PRINT STRING:s
    {:
      RESULT = new PrintInstruction(s, consoleController);
    :}
  | PRINT STRING:s expresionComplejo: e
    {:
      RESULT = new PrintInstruction(s, e, consoleController);
    :}
  | PRINT expresionConjunto:ec
    {:
      RESULT = new PrintSetInstruction(ec, consoleController);
    :}
  | DADO ID:id TALQUE expresionComplejo:e
    {:
      RESULT = new DeclareInstruction(id, e, variables);
    :}
  | EQUIVALE ID:id EQUALS expresionComplejo:e
    {:
      RESULT = new DeclareInstruction(id, e, variables);
    :}
  | EQUIVALE ID:id PLUS EQUALS expresionComplejo:e
    {:
      RESULT = new AssignOpInstruction(id, e, variables, "+");
    :}
  | EQUIVALE ID:id MINUS EQUALS expresionComplejo:e
    {:
      RESULT = new AssignOpInstruction(id, e, variables, "-");
    :}
  | EQUIVALE ID:id MULTIPLICATION EQUALS expresionComplejo:e
    {:
      RESULT = new AssignOpInstruction(id, e, variables, "*");
    :}
  | EQUIVALE ID:id DIVISION EQUALS expresionComplejo:e
    {:
      RESULT = new AssignOpInstruction(id, e, variables, "/");
    :}
  | EQUIVALE ID:id POW EQUALS expresionComplejo:e
    {:
      RESULT = new AssignOpInstruction(id, e, variables, "^");
    :}
  | EQUIVALE ID:id PLUS PLUS
    {:
      RESULT = new IncrementInstruction(id, variables, 1);
    :}
  | EQUIVALE ID:id MINUS MINUS
    {:
      RESULT = new IncrementInstruction(id, variables, -1);
    :}
  | DESDE ID:id AVANZAR expresionComplejo:end CON expresionComplejo:step bloque:body
    {:
      RESULT = new IterationInstruction(id, end, step, body, variables);
    :}
;

expresionConjunto ::=
    LEFT_BRACE listaExpresionesComplejos:le RIGHT_BRACE
    {:
      RESULT = () -> new Set(le);
    :}
  | expresionConjunto:ec1 UNION expresionConjunto:ec2
    {:
      RESULT = () -> {
        Set c1 = ec1.evaluate();
        Set c2 = ec2.evaluate();
        return c1.union(c2);
      };
    :}
  | expresionConjunto:ec1 INTERSECT expresionConjunto:ec2
    {:
      RESULT = () -> {
        Set c1 = ec1.evaluate();
        Set c2 = ec2.evaluate();
        return c1.intersect(c2);
      };
    :}
;

listaExpresionesComplejos ::=
    expresionComplejo:e
    {:
      List<ComplexExpression> expresiones = new ArrayList<>();
      expresiones.add(e);
      RESULT = expresiones;
    :}
  | expresionComplejo:e COMMA listaExpresionesComplejos:le
    {:
      List<ComplexExpression> expresiones = new ArrayList();
      expresiones.add(e);
      expresiones.addAll(le);
      RESULT = expresiones;
    :}
;

expresionComplejo ::= 
    REAL:r
    {:
      RESULT = () -> Complex.fromReal(r);
    :}
  | MINUS REAL:r
    {:
      RESULT = () -> Complex.fromReal(-r);
    :}
  | IMAGINARY:i
    {:
      RESULT = () -> Complex.fromImaginary(i);
    :}
  | DEGREES:d
    {:
      RESULT = () -> Complex.fromDegrees(d);
    :}
  | MINUS DEGREES:d
    {:
      RESULT = () -> Complex.fromDegrees(-d);
    :}
  | ID:id
    {:
      RESULT = () -> variables.get(id);
    :}
  | expresionComplejo:e1 PLUS expresionComplejo:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.add(c2);
      };
    :}
  | expresionComplejo:e1 MINUS expresionComplejo:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.substract(c2);
      };
    :}
  | expresionComplejo:e1 MULTIPLICATION expresionComplejo:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.multiply(c2);
      };
    :}
  | LEFT_PARENTH expresionComplejo:e1 RIGHT_PARENTH LEFT_PARENTH expresionComplejo:e2 RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.multiply(c2);
      };
    :}
  | expresionComplejo:e1 DIVISION expresionComplejo:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.divide(c2);
      };
    :}
  | expresionComplejo:e1 POW expresionComplejo:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.pow(c2);
      };
    :}
  | SIN LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.sin();
      };
    :}
  | COS LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.cos();
      };
    :}
  | TAN LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.tan();
      };
    :}
  | SEC LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.sec();
      };
    :}
  | CSC LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.csc();
      };
    :}
  | COT LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.cot();
      };
    :}
  | ROUND LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.round();
      };
    :}
  | LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () -> e.evaluate();
    :}
  | MINUS LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () -> 
      {
        Complex c = e.evaluate();
        Complex minus = new Complex(-1, -1);
        return c.multiply(minus);
      };
    :}
  | REAL:r LEFT_PARENTH expresionComplejo:e RIGHT_PARENTH
    {:
      RESULT = () -> 
      {
        Complex c = e.evaluate();
        return c.multiply(r);
      };
    :}
;
