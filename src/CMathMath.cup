import java_cup.runtime.*;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

parser code
{:
  public CMathMathParser(java_cup.runtime.Scanner s, ConsoleController consoleController) {
    super(s);
    this.consoleController = consoleController;
  }

  /**
   * Method automatically called on syntax errors.
   */
  public void syntax_error(Symbol s) {
    System.out.println("Error sintáctico en la línea " + (s.left) + " Columna " + (s.right) + ". No se esperaba este componente: " + (s.value) + ".");
  }

  /**
   * Method automatically called on a critical syntax error after which
   * error recovery is impossible.
   */
  public void unrecoverable_syntax_error(Symbol s) throws java.lang.Exception{
    System.out.println("Error sintáctico irrecuperable en la línea " + (s.left) + " Columna " + (s.right) + ". Componente " + (s.value) + " no reconocido.");
  }

  private Map<String, Complex> variables = new HashMap<>();
  private ConsoleController consoleController;
:}

terminal double REAL, IMAGINARY, DEGREES;
terminal PLUS, MINUS, MULTIPLICATION, DIVISION;
terminal String PRINT, LEFT_PARENTH, RIGHT_PARENTH, DADO, SI, EQUIVALE,
  SINO, PEROSI, F, MIENTRAS, DESDE, CON, AVANZAR, TALQUE, CONJUNTO, PI,
  LEFT_BRACE, RIGHT_BRACE, ID, SIN, COS, TAN, SEC, CSC, COT;

non terminal codigo;
non terminal List<Instruction> instrucciones;
non terminal Instruction instruccion;
non terminal List<Instruction> bloque;
non terminal Expression expresion;

precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION;

start with codigo;

codigo ::=
    instrucciones:ins
    {:
      for (Instruction in : ins)
      {
        in.run();
      }
    :}
;

instrucciones ::= 
    instruccion:in instrucciones:moreIns
    {:
      List<Instruction> instructions = new ArrayList<>();
      instructions.add(in);
      instructions.addAll(moreIns);
      RESULT = instructions;
    :}
  | instruccion:in
    {:
      List<Instruction> instructions = new ArrayList<>();
      instructions.add(in);
      RESULT = instructions;
    :}
  | error instrucciones
;

bloque ::= 
    LEFT_BRACE instrucciones:ins RIGHT_BRACE
    {:
      RESULT = ins;
    :}
;

instruccion ::= 
    PRINT expresion:e
    {:
      RESULT = new PrintInstruction(e, consoleController);
    :}
  | DADO ID:id TALQUE expresion:e
    {:
      RESULT = new DeclareInstruction(id, e, variables);
    :}
  | DESDE ID:id AVANZAR expresion:end CON expresion:step bloque:body
    {:
      RESULT = new IterationInstruction(id, end, step, body, variables);
    :}
;

expresion ::= 
    REAL:r
    {:
      RESULT = () -> Complex.fromReal(r);
    :}
  | IMAGINARY:i
    {:
      RESULT = () -> Complex.fromImaginary(i);
    :}
  | DEGREES:d
    {:
      RESULT = () -> Complex.fromDegrees(d);
    :}
  | ID:id
    {:
      RESULT = () -> variables.get(id);
    :}
  | expresion:e1 PLUS expresion:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.add(c2);
      };
    :}
  | expresion:e1 MINUS expresion:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.substract(c2);
      };
    :}
  | expresion:e1 MULTIPLICATION expresion:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.multiply(c2);
      };
    :}
  | expresion:e1 DIVISION expresion:e2
    {:
      RESULT = () ->
      {
        Complex c1 = e1.evaluate();
        Complex c2 = e2.evaluate();
        return c1.divide(c2);
      };
    :}
  | SIN LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.sin();
      };
    :}
  | COS LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.cos();
      };
    :}
  | TAN LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.tan();
      };
    :}
  | SEC LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.sec();
      };
    :}
  | CSC LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.csc();
      };
    :}
  | COT LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () ->
      {
        Complex c = e.evaluate();
        return c.cot();
      };
    :}
  | LEFT_PARENTH expresion:e RIGHT_PARENTH
    {:
      RESULT = () -> e.evaluate();
    :}
;
